# Deadlock Detection


#### 1. What does this program do?

The program simulates the behavior of multiple threads requesting for a different number of instances of different resources, and another thread is responsible to detect and resolve the presence of any deadlocks. For this purpose, in each thread, we generate a random set of resources and then request the resources from this set, one type at a time, in random order, with random pauses between making requests for different resource types. Deadlocks(if created) are detected and resolved by following termination based on different heuristics, thereby analyzing the efficiency of the followed heuristic.


#### 2. A description of how this program works (i.e. its logic)

The required inputs for the execution of the program are first supplied as the command-line arguments. These include the number of different types of resources, the names of these resource types, and the total number of instances of the resources individually. The number of threads to be created, the time interval between two successive deadlock checks, the total time after which the simulation should end, and the heuristic to be followed are also supplied as inputs. 

We set up a function `sig_handler()` responsible for addressing the termination of the program, producing meaningful results, when either the time-allowed has expired(`SIGALRM` generated by `alarm()`) or a signal indicating termination by the user(`SIGINT`) is received.

All the threads including the thread responsible for checking and resolving deadlocks after a periodic wait, are created by the `createAllThread()` function.

The `thread_simulator()` function simulates the execution of the worker threads. Firstly, the worker threads generate a random set of resources. Then, they request the resources from this set, one type at a time, in random order, with random pauses between making requests for different resource types. In order to ensure mutual exclusion between threads, when they write to global variables, we make use of a mutex lock, which is acquired before a write operation is to be performed to a global variable, and released after the operation has been performed. A conditional variable is also used in order to wait if the instances of the requested resource are more than the currently available instances of the same resource. Once, the wait is over, the thread acquires all the requested instances of the resource. Once a thread acquires the complete set of resources as requested earlier, it waits for some time and then releases them all at once. A signal is broadcasted to the threads waiting on the conditional variable so that the wait condition can be re-evaluated.

The deadlock detection thread is simulated by the function `dlock_detection_thr()`. It uses the deadlock detection algorithm to find out whether all the threads can be finished, given the request matrix, allocation matrix, and an array of the available resources. Once a deadlock is detected, we terminate the worker threads involved in the deadlock, one by one, by using suitable heuristics. The heuristics followed to select the thread to be terminated include the maximum number of total resources owned, the maximum instances of any resource allocated, the minimum number of total resources allocated, the minimum instances of any resource allocated, linear order of deadlocked threads, etc. The termination is essentially performedby making the corresponding rows of `allocate`, `request`, and `cur_request` as zero, and freeing up the resources allocated to the thread.


Finally, we calculate the average time between successive deadlocks, obtained by following a particular heuristic. The program terminates when either a `SIGALRM` or `SIGINT` signal gets generated.

#### 3. How to compile and run this program

&nbsp;&nbsp;&nbsp;&nbsp;To compile the program:

&nbsp;&nbsp;&nbsp;&nbsp;`gcc main.c -lpthread`

&nbsp;&nbsp;&nbsp;&nbsp;To execute the server:

```
  ./a.out  max_num_threads  deadlock_detection_interval  heuristic_selected  total_simulation_time  seed  total_types_resources  resource_1_name  resource_1_max_instances  resource_2_name  resource_2_max_instances ....
```

where,
`max_num_threads` = The maximum number of threads to be used in the simulation
`deadlock_detection_interval` = The time interval in seconds between two successive deadlock detection checks
`heuristic_selected` = A number from 1 to 5 denoting one of the following heuristics to be adopted for resolving deadlocks
1. Terminate thread with maximum number of total resources allocated.
2. Terminate thread with maximum instances of any resource allocated.
3. Terminate thread with minimum number of total resources allocated.
4. Terminate thread with minimum instances of any resource allocated.
5. Terminate thread in a linear order of deadlocked threads.

`total_simulation_time` = The time(in seconds) after which the simulation should end
`seed` = The value of seed to be supplied to the random generator function
`total_types_resources` = The total number of types of resources

These arguments are followed by the resource names and their corresponding maximum available instances. Count of the resource types is determined by `total_types_resources`.

**Commands for a sample run**
```    
    gcc main.c -lpthread
    ./a.out 8 3 1 25 42 4 A 10 B 8 C 9 D 7
```

4. Provide a snapshot of a sample run

```
    ==========================Simulation==========================
    Parameters for simulation :: 
    Number of types of resources = 4
            A = 10
            B = 8
            C = 9
            D = 7
    Number of threads = 8
    Deadlock detection interval = 3 sec
    Heuristic number = 1
    Execution Time = 8 sec

    Allocate 6 number of instances of resource type 0 to thread 1
    Allocate 1 number of instances of resource type 1 to thread 2
    Allocate 4 number of instances of resource type 0 to thread 4
    Allocate 2 number of instances of resource type 3 to thread 5
    Allocate 1 number of instances of resource type 1 to thread 6
    Allocate 3 number of instances of resource type 1 to thread 0
    Allocate 4 number of instances of resource type 2 to thread 1
    Allocate 4 number of instances of resource type 2 to thread 6
    Allocate 3 number of instances of resource type 3 to thread 2
    Allocate 3 number of instances of resource type 1 to thread 2

    LOG: Deadlock detection started...
    LOG: Deadlock Detected. Threads in deadlock are: 0 1 2 4 5 6 
    LOG: Terminating thread 1 and retrying...
    LOG: Deadlock Detected. Threads in deadlock are: 0 2 4 5 6 
    LOG: Terminating thread 2 and retrying...
    LOG: Deadlock Resolved.

    Allocate 5 number of instances of resource type 0 to thread 3
    Allocate 3 number of instances of resource type 2 to thread 4
    Allocate 3 number of instances of resource type 3 to thread 5
    Allocate 1 number of instances of resource type 1 to thread 6
    Allocate 1 number of instances of resource type 3 to thread 5
    Allocate 2 number of instances of resource type 2 to thread 5

    LOG: Deadlock detection started...
    LOG: Deadlock Detected. Threads in deadlock are: 0 3 4 5 6 
    LOG: Terminating thread 5 and retrying...
    LOG: Deadlock Detected. Threads in deadlock are: 0 3 4 6 
    LOG: Terminating thread 4 and retrying...
    LOG: Deadlock Detected. Threads in deadlock are: 0 3 
    LOG: Terminating thread 3 and retrying...
    LOG: Deadlock Resolved.

    Allocate 3 number of instances of resource type 0 to thread 7
    Allocate 4 number of instances of resource type 2 to thread 6
    Allocate 2 number of instances of resource type 0 to thread 0
    Allocate 1 number of instances of resource type 0 to thread 7
    Allocate 2 number of instances of resource type 0 to thread 7
    Allocate 1 number of instances of resource type 3 to thread 7
    Allocate 1 number of instances of resource type 0 to thread 7

    LOG: Total allowed execution time has been reached. Program terminating...
    LOG: Total number of deadlocks = 2
    LOG: Average time between deadlocks = 3.000477 sec
    LOG: Program Terminated.
```
    